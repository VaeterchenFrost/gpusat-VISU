% Paperformat
\documentclass[a4paper, 12pt]{scrartcl}
%\usepackage{cite}
\usepackage{ragged2e}
\usepackage{url}
\usepackage{bm} % bold math
\usepackage{nccmath} % medium fraction with mfrac 
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsthm} % theorems
\usepackage{hyperref}
\usepackage{float}
\usepackage{listings} % code
\usepackage{xcolor}
\usepackage{longtable} % breaks pages
\usepackage{tabularx}
\usepackage{thmtools}
\usepackage{booktabs}
\usepackage[export]{adjustbox}

\declaretheoremstyle[
headfont=\bfseries,
notefont=\bfseries,
notebraces={(}{)},
qed=,
headpunct=.,
headformat={\mbox{\NAME{} \NUMBER\NOTE}}
]{custom}

\declaretheorem[style=custom, name=Theorem]{thm}
\declaretheorem[style=custom, name=Example]{example}

\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{bibtex.bib}

\definecolor{light-gray}{gray}{0.9}
\lstset{tabsize=2, linewidth=1.05\textwidth, framextopmargin=1em, basicstyle=\small\ttfamily}
\lstset{numbers=left,backgroundcolor=\color{light-gray}}
\newtheorem{theorem}{Theorem}[section]


\begin{document}
\def\myauthor{Martin Röbke} 
\def\mycoauthor{Dr. Johannes Fichte} 
\def\mytitle{Visualizing Dynamic Programming on Tree Decompositions} 
\def\mydate{\today} 
\def\mymatriculation{3949819}
\def\mybirthday{04.03.1995}
\def\myemail{Martin.Roebke@tu-dresden.de}

\begin{titlepage}
	\vspace*{\stretch{1}}
	\begin{center}
		\textsc{\large 
		{Technische Universität Dresden \\
			Fakultät Informatik} \\
		[8ex]}             
		{\Large\bfseries Bachelor Thesis}           \\[12ex]
		
		{\huge\bfseries \mytitle}                  \\[6.5ex]
		
		\vspace{12ex}
			
		
		{\Large 
		\begin{tabular}{p{0.4\textwidth}r}
		
			\textit{Author:}&  \textit{Supervisor:}\\
			
			\myauthor &  Dr. Johannes Fichte\\[20ex]
		
		\end{tabular}
		}
		
		
		\vfill
		\textsc{International Center For Computational Logic 		\\[4ex]}
		\mydate
	\end{center}
	\vspace{\stretch{2}}
\end{titlepage}
\newpage
%==============================================================================
%============== DECLARATION ===================================================
%==============================================================================
\section*{ }
\thispagestyle{empty}
{\huge\bfseries{Erklärung zur Urheberschaft}\vspace{20pt}}

\noindent
Hiermit versichere ich, dass diese Arbeit von mir persönlich verfasst ist und dass ich
keinerlei fremde Hilfe in Anspruch genommen habe. Ebenso versichere ich, dass diese Arbeit
oder Teile daraus weder von mir selbst noch von anderen als Leistungsnachweis oder als Leistung, die als Prüfungsvoraussetzung
zu erbringen war, andernorts bereits eingereicht wurden. Wörtliche oder sinngemäße Übernahmen aus anderen Schriften
oder Veröffentlichungen in gedruckter oder elektronischer Form sind gekennzeichnet.
Sämtliche Sekundärliteratur und sonstige Quellen sind nachgewiesen und in der Bibliographie aufgeführt.
Das Gleiche gilt für graphische Darstellungen und Bilder sowie für alle Internet-Quellen. \\[20pt]

\noindent
\myauthor \\
Matrikelnummer \mymatriculation\\
Geburtsdatum \mybirthday\\\\
TU Dresden E-Mail-Adresse:\\
 \myemail\\[40pt]


Dresden,  ............................. \hfill .............................
\begin{flushright}
	(Unterschrift)\hspace{1em}
\end{flushright}


\newpage

%==============================================================================
%============== ABSTRACT ======================================================
%==============================================================================
\section*{Abstract}
\vspace{4ex}

"A picture is worth a 100 spreadsheets" - better Analysis
 
Answering questions that be expressed using graph theory is increasingly interesting in scientific work.
Many problems such as Boolean satisfiability or problems related to traffic can be translated to and solved on a graph.
We think that the use of graph structures can help to further develop algorithms in different areas.

The algorithms we visualize in this thesis use dynamic programming on tree decompositions.
We preprocess the input graph into a customized tree-decomposition of small tree-width.
This gives us a description of the processing sequence for the algorithm, and allows 
with right hindsight for good parallelization and allows for faster solving times on larger instances.

To help further refine and visualize the dynamic programming,
we specified a JSON template for communication between solvers and the newly created visualization tool \href{https://github.com/VaeterchenFrost/tdvisu}{TDVisu}.

As two reference implementations of dynamic programming on tree decompositions we selected the existing solvers \href{https://github.com/daajoe/GPUSAT}{GPUSAT} and \href{https://github.com/hmarkus/dp_on_dbs}{dpdb}.


\newpage

%  table
\tableofcontents

% chapter on next page
\newpage

%==============================================================================
%============== INTRODUCTION ==================================================
%==============================================================================

\section{Introduction}
\subsection{Motivation}
Graphs are increasingly interesting in scientific work, as the applications of interconnected datasets grow.
Some use cases for example outlined \href{http://neo4j.com/use-cases}{here} do include fields of interest like
\begin{itemize}
	\item[-] Network and Database Infrastructure
	\item[-] Recommendation Engines
	\item[-] Artificial Intelligence and Analytics
\end{itemize}
It defines a \href{https://www.json.org/json-en.html}{JSON}-format specification for portability and customization of the visualization combined in one human-readable file and two reference implementations in actual solvers.
The implementation currently does not support hyper-graphs and assumes that each node in the tree decomposition has either one or two children.
The visualization output consists by default of scalable-vector-graphics \href{https://developer.mozilla.org/en-US/docs/Web/SVG}{SVG}, a very flexible text-based that can be compressed and modified very easily without loss of quality.
The images are split up into different views on the current state of the tree decomposition for consecutive user-defined time steps showing the progress of the dynamic programming.
As illustrations of the possibilities for an application smaller examples from the problem-types "\#SAT" and "minimal vertex cover" are presented,
as well as an example of a faulty tree-decomposition that occurred during development.
Intended audience: 
\begin{itemize}
	\item Developer of dynamic programming on tree decompositions for debugging.
	\item Researcher of such algorithms for comparisons and visualizations.
	\item Teachers or students looking for automatic visualization of their examples and the dynamic programming.
\end{itemize} 

The idea for this project comes from my supervisor Dr. Johannes Fichte, who works with many projects such as \href{https://github.com/hmarkus/dp_on_dbs}{dpdb} on solving monadic second order logic (MSOL\cite{Courcelle2012}) problems using highly parallelized architectures like graphics processing units or state of the art databases.
One early implementation is published in \cite{evaluationMSO} where for different real world examples the results looked promising
These projects are very competitive ????REF????? for solving even large instances of those problems.
The source code for TDVisu is available under GPL3 license.

\href{https://graphviz.org/}{Graphviz} is open source graph visualization software that provides
customizable visualization for directed and undirected graphs.
The information processed by graphviz 

%============== Concept ====================================================
\subsection{Concept}

Stand Umsetzung, Tools: Slack, Trello, GitHub, Presentations

Research: language (python - explain) graph-construction (graphviz vs networkX), examples (diploma at first). 

My experience with the topics of this work comes mainly from the two courses:
\begin{itemize}
	\item Visualization with python from the lecture "Computational Physics" by Prof. Dr. A. Bäcker,
	chair of computational physics, TU Dresden 2016
	\item algorithms and various manipulations on graphs from the lecture "Graph Data Management and Analytics" by Hannes Voigt. \cite{VLGDMA}
\end{itemize}

%============== Rel Work ====================================================
\subsection{Related Work}
intro. mit motivation und related work, state of the art, advancements.

Visualization Pipeline
%============== Outline ====================================================
\subsection{Thesis Outline}


%==============================================================================
%============== BACKGROUND ====================================================
%==============================================================================
\newpage
\section{Background}
\textit{In this chapter we provide a brief background on }.

We begin with a description on SAT and \#SAT as examples for a very general problem that can be described with monadic second order logic (MSOL).
Furthermore the general case of MSOL will be described, as well as the \textit{DIMACS}-file-format used in the projects.
The following section describes Tree Decompositions (TDs) which are the basis for our visualization. 
Finally we shortly discuss Courcelle's Theorem~\cite{Courcelle2012} as a related method of solving these problems.

%============== SAT ====================================================
\subsection{Boolean satisfiability problem}
% https://en.wikipedia.org/wiki/Boolean_satisfiability_problem

%SAT was the first known NP-complete problem, shown by Stephen Cook at the University of Toronto in 1971 \cite{SAT1971}

%\begin{align*}
%\text{literal}&\equiv \text{boolean variable v or its negation} \\
%\text{clause}&\equiv \text{finite set of literals, interpreted as the disjunction} \\
%\text{unit}&\equiv \text{clause with $|$c$|$=1} \\
%\text{CNF formula}&\equiv \text{set of clauses, interpreted as their conjunction} \\
%\text{var}&\equiv \text{set of variables contained in the clause or clause set C} \\
%\text{assignment}&\equiv \text{$\alpha $:var(C) $\to $ \{0,1\}} \\
%\text{satisfiedclause}&\equiv \text{if $\exists $v $\in $ var(c), v$\in $c and $\alpha $(v)=1 or $\neg $v$\in $c and $\alpha $(v)= 0. Otherwise falsified}\\ 
%\text{satisfiedform}&\equiv \text{each clause in the formula is satisfied by assignment} \\
%\end{align*}

A literal is a boolean variable $v$ or its negation $\neg v$. A $clause$ is a finite set of literals interpreted as their disjunction. A clause $c$ is called $unit$ if $|c|=1$. A CNF $formula$ is a set of clauses and is interpreted as the conjunction of its clauses. We define $var(C)$ as the set of variables contained in the clause or clause set C. As $assignment \alpha$ maps variables in a formula to 0 or 1, $\alpha : var(C)\rightarrow 0,1$. A clause is satisfied by an assignment if for some variable $v \in var(c)$ we have $v \in c \land \alpha (v)=1$ {or} $\neg v \in c \land \alpha(v)=0$. Otherwise the assignment falsifies the clause. An assignment satisfies a formula if each clause in the formula os satisfied by the assignment. \\
A set C of clauses is 
\begin{itemize}
	\renewcommand{\labelitemi}{-}
	\item \textit{unfalsifiable if there is an assignment that falsifies all clauses in it}. This can only exist when there exists a variable $v \in var(C)$ such that $v \in C$ and $\neg a \in C$. 
	\item \textit{falsifiable} if there is an assignment that falsifies all clauses in C.
	\item \textit{satisfiable} if there is an assignment that safisfies all clauses in C.
	\item \textit{unsatisfiable} if there does not exist an assignment that safisfies all clauses in C.
\end{itemize}

% EXAMPLE 4.1?
\begin{example}[\label{ex:example41}]
	We will mostly use the formula with the following clause set: $C=\{c_{1}=\{v_{1},v_{4},v_{6}\},
	c_{2}=\{v_{1},\neg v_{5}\},
	c_{3}=\{\neg v_{1},v_{7}\},
	c_{4}=\{v_{2},v_{3}\},
	c_{5}=\{v_{2},v_{5}\},
	c_{6}=\{v_{2},\neg v_{6}\},
	c_{7}=\{v_{3},\neg v_{8}\},
	c_{8}=\{v_{4},\neg v_{8}\},
	c_{9}=\{\neg v_{4},v_{6}\},
	c_{10}=\{\neg v_{4},v_{7}\}\}$
\end{example}

Connection to graphs with \cite{DiplomarbeitZisser}

SAT Handbook:
Even finding a single solution can be a challenge
for such problems; counting the number of solutions is much harder.Not
surprisingly, the largest formulas we can solve for the model counting problem
with state - of - the - art model counters are orders of magnitude smaller than the
formulas we can solve with the best SAT solvers. Generally speaking, current
exact counting methods can tackle problems with a couple of hundred variables, while approximate counting methods push this to around 1, 000 variables.

%============== MSOL ====================================================
\subsection{Monadic Second Order Logic}
See also figure~\ref{fig:logictheory}.

Explain graphs?Node, Edge

MSO graph properties are "fixed-parameter-tractable" with respect to clique-width and tree-width. 
\url{https://www.youtube.com/watch?v=hZI-wANHO1w} 5th workshop on Graph Classes, Optimization, and Width Parameters (GROW 2011)
2011-10-28.
MSO counting (k-colorings )and optimizing (distance between two vertices...) functions.
Interested in MSO logic over graphs.

Two types of MSO formulas \textit{or logical graph representations}.
\begin{itemize}
	\item MSO formulas
	\item MSO$_{2}$ formulas with edge quantification $\equiv$ MSO formulas over incidence graphs
\end{itemize}
\begin{itemize}
	\item G=(vertices, edges as binary relation)
	\item INC(G) = (vertices and edges, Inc)
		for G undirected: Inc(e,v) <-> v is a vertex of edge e
\end{itemize}
\begin{itemize}
	\item FPT for clique width
	\item FPT for tree-width
\end{itemize}
This can also be done for directed graphs!

Typical MSO$_{2}$ graph properties:

has a perfect matching
has a Hamiltonian circuit
spanning tree of degree $\le$ 3

The expressions have the form: "There exists a \textbf{set of edges} that is..." can not be transferred into "set of vertices"

\url{https://youtu.be/Wyn3djrYg7c?t=1385} Bruno Courcelle: Recognizable sets of graphs: algebraic and logical aspects 
\url{https://library.cirm-math.fr/Record.htm?idlist=2&record=19276851124910940339}
Recording during the thematic meeting: "Frontiers of reconnaissability" the April 29, 2014 at the Centre International de Rencontres Mathématiques (Marseille, France)

FPT for model checking:
An algorithm is FPT if it takes time $f(k)\cdot n^{c}$ for some fixed function f and constant c. The size of the input is n. 
The value k is a parameter of the input. 
This algorithm is then usable for small values of k. usually tree-width and clique width.

%============== Courcelle ====================================================
\subsection{Courcelle's Theorem}
\begin{quotation}
	Every graph property definable in monadic second-order logic (MSO) is decidable in linear time on graphs of bounded tree-width.\\
	{\small Courcelle, Bruno (1990)}\footnote{Courcelle, Bruno "The monadic second-order logic of graphs. I. Recognizable sets of finite graphs",\\ Information and Computation, 85 (1990) no. 1: 12-75}
\end{quotation}

For all $k \in \mathbb{N}$ and MSO-sentences F is the decision problem for a given graph G, whether $G \models F$ is true, in time $2^{p(tw(G))} \cdot |G|$ with a polynom p decidable.
\begin{itemize}
	
	\item \emph{drawback:} still expensive ($2^{p(tw G)}$, $2^{2^{(\#Q)}}$, large constants) \smallskip 
	
\end{itemize}

The workflow then looks like we see in figure~\ref{fig:UsageCourcelle}.

\begin{figure}[H]
	\includegraphics[height=0.2\textheight]{images/UsageCourcelle.gv.png}
	\caption{Implementation of the theorem}
	\label{fig:UsageCourcelle}
\end{figure}

%============== TD ====================================================
\subsection{Tree Decomposition}
Used in RNA Folding: Novel prediction techniques are developed based on graph tree decomposition. \cite{BioInfoTD1970}
\cite{DiplomarbeitZisser}chapter 2.2
Tree decompositions were originally introduced by Robertson and Seymour \cite{ROBERTSON198449} in 1984.
A \textit{tree decomposition} (TD) of a graph G is a pair $(T, \chi)$. $T$ is a tree and $\chi$ is a mapping which assigns each node $n~\in~V(T)$ 
a set $\chi(n) \subseteq V(G)$ called a \textit{bag}. Then $(T, \chi)$. $T$ is a TD if the following conditions hold:

\begin{itemize}
	\item[1.] for each vertex $v(n) \in V(G)$ there is a node $n \in V(T)$ such that $v \in \chi(n)$
	\item[2.] for each edge $(x,y) \in E(G)$ there is a node $n\in V(T)$ such that $x,y \in\chi(n)$
	\item[3.] if $x,y,z \in V(T)$ and $y$ lies on the path from x to z then $\chi(x) \cap \chi(z) \subseteq \chi(y)$.
\end{itemize}
The width $width(T)$ of a tree decomposition $T$ is $max_{n\in V(T)}(|\chi(n)|)-1$.
The tree width of a graph is the \textit{minimal width} over all tree decompositions of the graph.

!!!Example (can take one from the visualizations) also in \cite{pcgp2019} page 169

%============== DIMACS ====================================================
\subsection{DIMACS format}
Developed in 1993 at Rutgers University.
DIMACS (the Center for Discrete Mathematics and Theoretical Computer Science)

Wolfram Language fully supports the DIMACS format for storing a single undirected graph.
\url{https://reference.wolfram.com/language/ref/format/DIMACS.html}

DIMACS CNF: This format is used to define a Boolean expression, written in conjunctive normal form.
\url{https://people.sc.fsu.edu/~jburkardt/data/cnf/cnf.html}

Other formats for WMC, different graphs...

Supported also in Maple \url{https://www.maplesoft.com/support/help/maple/view.aspx?path=Formats/CNF}

Examples in appendix

%============== DOT ====================================================
\subsection{DOT format}
The graph description language DOT can be used to describe directed or undirected graphs and specify layout details and various attributes for graphs, edges and nodes. It is similar to the Graph Modeling Language as a text based file format for describing graphs, and the Graphviz project includes gml2gv and gv2gml as two tools that can convert between GML and DOT files.

Attributes (new site): http://www.graphviz.org/doc/info/attrs.html

List specialized types for input used.
rankdir "TB", "LR", "BT", "RL", corresponding to directed graphs drawn from top to bottom, from left to right, from bottom to top, and from right to left, respectively. 

fillcolor  \url{https://graphviz.org/doc/info/attrs.html#k:color} \url{https://graphviz.org/doc/info/colors.html} 
If the value is a colorList, a gradient fill is used. By default, this is a linear fill; setting style=radial will cause a radial fill. 

fontcolor Color used for text. 

style for nodes \url{https://graphviz.org/doc/info/attrs.html#d:style}
At present, the recognized style names are "dashed", "dotted", "solid", "invis" and "bold" for nodes and edges,  and "filled", "striped", "wedged", "diagonals" and "rounded" for nodes only.


margin not customizable, node attr margin='0.11,0.01' \url{https://graphviz.org/doc/info/attrs.html#d:margin}

fontsize Font size, in points, used for text. 


penwidth Specifies the width of the pen, in points, used to draw lines and curves, including the boundaries of edges and clusters. 

nodesep In dot, this specifies the minimum space between two adjacent nodes in the same rank, in inches. 

shape https://graphviz.org/doc/info/shapes.html

%=========================== DOT Language ====================================

Dot Language: http://www.graphviz.org/doc/info/lang.html

The nodes in the dot-language are \emph{labeled}, so creating a node takes one string identifier and
can additionally be provided a string label. Valid examples for IDs include: a, b, A1, node1.
The complete abstract grammar for DOT can be viewed at \href{https://graphviz.gitlab.io/_pages/doc/info/lang.html}{the DOT language}.

It supports directed (\textit{digraph} with edges indicated by '->') an undirected (\textit{graph} with edges indicated by '-{}-') graphs.
The visualizations presented here are constructed as undirected graphs, but would be easily extendable to directed representations since almost all operations keep the order of edge-endpoints given as input.

Another concept utilized were the sub-graphs and clusters available in DOT.
To get a well structured (bipartite) incidence graph, each partition is placed in an individual cluster
and sorted by node-label to easier find single nodes in potentially large clusters.


%==============================================================================
%============== PROJECT =======================================================
%==============================================================================
\newpage
\section{My Visualization Project}


Python because: Rich dependency environment. Fast prototyping. Simple tooling for debugging (pdb), static analysis (mypy), code-style (pylint, autopep8), packaging (pip, pypi).

Python 3.8 because: Python 3.8 was the newest python version at the beginning of the project, released on October 14th 2019. The change applied most times in this project would be \href{https://docs.python.org/3/whatsnew/3.8.html#f-strings-support-for-self-documenting-expressions-and-debugging}{f-string support} for shorter and easier to read string-building - for a longer list see \href{https://docs.python.org/3/whatsnew/3.8.html}{summary of release highlights}.

The development process was for most parts of the final software driven by evolutionary prototyping with the help of small and well understood examples such as \ref{fig:g41Digraph}. It helped to understand the possibilities of visualization in this domain and gather user input and requirements early \cite{rapidPrototypingOvermyer}. Some artifacts of the early prototypes with different graph-description languages can be still seen in the class \textit{Graphoutput} in \ref{chagraphoutput}.

The first steps were in \url{https://github.com/VaeterchenFrost/gpusat-VISU} and the first releases of the source code outsourced to\url{https://github.com/VaeterchenFrost/tdvisu}

The objective of this project was/is to support the visualization mainly to document and improve the development efforts of dynamic programming on tree decompositions.

The tree decompositions in every tested application were provided by the utility \url{https://github.com/mabseher/htd} (small but efficient C++ library for computing (customized) tree and hypertree decompositions).


% License

% Files / Classes / Methods
%============== CMD Config ====================================================
\subsection{Commandline and Configuration}


The \textit{tdvisu.visualization} expects the command line parameters in a format described by table~\ref{tab:optionstdvisu}.

\def\arraystretch{1.2}%  1 is the default
\begin{longtable}{|ll|}
	\caption{Usage visualization.py 
		\label{tab:optionstdvisu}}\\
	\hline 
	\multicolumn{2}{|c|}{[-h] [--version] [--loglevel LOGLEVEL] [infile] outfolder}
	\\[2ex]
	\endfirsthead

	infile=stdin &  Input file for the visualization must conform with the JsonAPI.md\\
	outfolder &  Foldername to output the visualization results to\\
	-{}-loglevel  &   set the minimal loglevel for the root logger\\
	-{}-version & show program's version number and exit\\
	-h, -{}-help & show the help message and exit\\
	\hline
\end{longtable}

We see that this input is very simple, and that the heavy lifting is done with the input file given in \textit{infile}.

One extra possibility for configuration comes with the method \textbf{logging\_cfg} from {tdvisu.utilities}. There are two example configurations provided with our project, one in the .yml, one in the .ini format. The implementation is very flexible in detecting which parser has to be applied - either via a dictionary-like or a configuration-like function. Both possibilities are documented in python's \href{https://docs.python.org/3/library/logging.config.html#logging-config-api}{logging configuration}.

Our default configuration in tdvisu/logging.yml and tdvisu/logging.ini provides one handler, two formatters and six loggers.

The \textbf{handler} is a stream handler to sys.stdout with level \textit{WARNING} and the the 'full'-formatter to format messages.

The \textbf{full-formatter} includes the full date and time up to milliseconds. After that we can expect the logging-level, filename and line where it was generated, and the message itself.

The \textbf{loggers} we use in our project are located in 
\begin{itemize}
	\item root, level: WARNING
	\item visualization.py, NOTSET
	\item svgjoin.py, NOTSET
    \item reader.py, NOTSET
	\item construct\_dpdb\_visu.py, NOTSET
	\item utilities.py, NOTSET
\end{itemize}
and can be individually customized using one configuration file.
With the command line parameter \textit{-{}-loglevel} we can modify the level of \textit{root} and it's associated handlers.

%============== Init ====================================================
\subsection{Initialization and Tree Decomposition}

After the configuration we instantiate a Visualization object as shown in listing~\ref{lst:visuinit} , which parses the VisualizationData with the help from our inspect\_json method. 

The main purpose of the initialization is parsing the input file containing visualization information.
This is encapsulated in \textit{read\_json}.

Next we want to extract information into two places: 
\begin{itemize}
	\item the instance variables 
	\begin{itemize}
		\item \textit{timeline}, describing the time steps on the tree decomposition
		\item \textit{tree\_dec}, describing the TD itself
		\item \textit{bagpre}, \textit{joinpre}, \textit{solpre} and \textit{soljoinpre} as names for different nodes in the produced visualization
	\end{itemize}
	\item \textit{VisualizationData} containing the data for 
	\begin{itemize}
		\item IncidenceGraphData in listing \ref{lst:incidencedata}
		\item GeneralGraphData in \ref{lst:gengraphdata}
		\item SvgJoinData in \ref{lst:svgjoindata}
		\item adjustable parameters affecting the visuals of the visualization
	\end{itemize}
\end{itemize}


\begin{lstlisting}[language={Python}, caption={Initializing a Visualization object}, label={lst:visuinit}]
def __init__(self, infile, outfolder) -> None:
	"""Copy needed fields from arguments and create VisualizationData.
	"""
	self.data: VisualizationData = self.inspect_json(infile)
	self.outfolder = outfolder
	
	self.tree_dec_digraph = None
	
def inspect_json(self, infile) -> VisualizationData:
	"""Read and preprocess the needed data from the infile into 
	VisualizationData.
	"""
	LOGGER.debug("Reading from: %s", infile)
	visudata = read_json(infile)
	LOGGER.debug("Found keys: %s", visudata.keys())
	
	try:
		_incid = visudata['incidenceGraph']
		_general_graph = visudata['generalGraph']
		_svg_join = visudata.get('svg_join', None)
		
		incid_data: IncidenceGraphData = None
		if _incid:
		_incid['edges'] = [[x['id'], x['list']]
		for x in _incid['edges']]
		incid_data = IncidenceGraphData(**_incid)
		visudata.pop('incidenceGraph')
		general_graph_data: GeneralGraphData = None
		if _general_graph:
		general_graph_data = GeneralGraphData(**_general_graph)
		visudata.pop('generalGraph')
		svg_join_data: SvgJoinData = None
		if _svg_join:
		svg_join_data = SvgJoinData(**_svg_join)
		if 'svg_join' in visudata:
		visudata.pop('svg_join')
		
		self.timeline = visudata['tdTimeline']
		visudata.pop('tdTimeline')
		self.tree_dec = visudata['treeDecJson']
		self.bagpre = self.tree_dec['bagpre']
		self.joinpre = self.tree_dec.get('joinpre', 'Join %d~%d')
		self.solpre = self.tree_dec.get('solpre', 'sol%d')
		self.soljoinpre = self.tree_dec.get('soljoinpre', 'solJoin%d~%d')
		visudata.pop('treeDecJson')
	except KeyError as err:
		raise KeyError(f"Key {err} not found in the input Json.")
	return VisualizationData(incidence_graph=incid_data,
													 general_graph=general_graph_data,
													 svg_join=svg_join_data,
													 **visudata)

\end{lstlisting}

\begin{lstlisting}[language={Python}, caption={SvgJoinData}, label={lst:svgjoindata}]
@dataclass
class SvgJoinData:
	"""Class holding different parameters to join the results."""
	base_names: Union[str, Iterable[str]]
	folder: Optional[str] = None
	outname: str = 'combined'
	suffix: str = '%d.svg'
	preserve_aspectratio: str = 'xMinYMin'
	num_images: int = 1
	padding: Union[int, Iterable[int]] = 0
	scale2: Union[float, Iterable[float]] = 1.0
	v_top: Union[None, float, str, 
	             Iterable[Union[None, float, str]]] = None
	v_bottom: Union[None, float, str, 
	                Iterable[Union[None, float, str]]] = None	
\end{lstlisting}

\begin{lstlisting}[language={Python}, caption={IncidenceGraphData}, label={lst:incidencedata}]
@dataclass
class IncidenceGraphData:
	"""Class holding different parameters for the incidence graph."""
	edges: list
	subgraph_name_one: str = 'clauses'
	subgraph_name_two: str = 'variables'
	var_name_one: str = ''
	var_name_two: str = ''
	infer_primal: bool = False
	infer_dual: bool = False
	primal_file: str = 'PrimalGraphStep'
	inc_file: str = 'IncidenceGraphStep'
	dual_file: str = 'DualGraphStep'
	fontsize: int = 16
	penwidth: Union[float, str] = 2.2
	second_shape: str = 'diamond'
	column_distance: float = 0.5	
\end{lstlisting}

\begin{lstlisting}[language={Python}, caption={GeneralGraphData}, label={lst:gengraphdata}]
@dataclass
class GeneralGraphData:
	"""Class holding different parameters for the general graph."""
	edges: list
	extra_nodes: Optional[list] = None
	graph_name: str = 'graph'
	file_basename: str = 'graph'
	var_name: str = ''
	sort_nodes: bool = False
	need_adj_nodes: bool = False
	fontsize: int = 20
	first_color: str = 'yellow'
	first_style: str = 'filled'
	second_color: str = 'green'
	second_style: str = 'dotted,filled'
\end{lstlisting}

Next we call the method \textit{Visualization.tree\_dec\_timeline} that will start the visualization.
First, a quick setup is performed for a directed graph that 
\begin{itemize}
	\item is \textit{strict}, meaning a simple graph where equal edges are merged into one
	\item has an orientation where it grows with each "rank" of the nodes
	\item has a shape and a fill-color for it's nodes
	\item has a margin around it's bounding box.
\end{itemize}

Second, it creates the basic bag structure by adding nodes and edges for all bags of the provided tree decomposition.

Next comes the longest calculation when iterating over the time steps, adding the provided solutions and the edges connecting them to the existing bags. We do this in two passes, one in which we put all the nodes in their final position and one in which we create the final time step images. A special case occurs when two bags are joined into a new bag.

In this case, we remove all old edges between the children and the parent node, add the link result to the graph, and add edges from the children to the link result and from the link result to the parent node. Details of this function can be seen in listing \ref{lst:forward-iterate}.

An automatically inserted join node is shown in figure~\ref{fig:g41Digraph}.
The provided data for this example to layout the bags is listing\ref{lst:edgearray41}. Here we see that bags 2 and 3 have an edge to bag 1:

\begin{lstlisting}[caption={Structure provided for bags of example \ref{fig:g41Digraph} },label={lst:edgearray41},numbers=none,backgroundcolor=\color{white}]
"edgearray" : 
[
	[ 1, 0 ],
	[ 2, 1 ],
	[ 3, 1 ],
	[ 4, 3 ]
]
\end{lstlisting}

The second run iterates backwards over all time steps to hide later time steps and emphasize the current node.
When rendering the graphs there is an added option to automatically \textit{view} the result (disabled by default). Details of this function can be seen in listing \ref{lst:backward-iterate}.

%============== Timesteps ====================================================
\subsection{Create time steps for the underlying graph}
To get a more comprehensive insight into the solving process we decided to also highlight the parts of graphs that best describe the problem instance the solver worked on.

Because the data in the API does not directly include details about highlights in those graphs, we will construct this information on the fly.

First we select only bag ids from the timeline provided that represent an IF-operation.
With additional data from \textit{IncidenceGraphData} we are able to reconstruct the
\begin{itemize}
	\item incidence graph,
	\item primal graph,
	\item dual graph
\end{itemize}
for Boolean formulas.
With input from \textit{GeneralGraphData} we can construct a simple graph that should include the nodes we find in the bags of the TD.

% ----- Example for isolated nodes -------
Because graph representations of Boolean formulas are not necessarily connected, we make sure to include potentially isolated nodes into the graph as well.
For example the formula $(\neg a\lor \neg b\lor \neg c\lor \neg d)\land (b\lor c\lor d)\land g$
with its set of clauses $\{c_{1}=\{-a,-b,-c,-d\},c_{2}=\{b,c,d\},c_{3}=\{g\}\}$ will create the dual graph \ref{fig:disconnected123}. This happens with no pre-processing and if the variable g is only included in the unit $c_{3}$.

\begin{figure}[H]
	\centering
	\includegraphics{images/disconnected123.png}
	\caption{Disconnected (dual) graph}
	\label{fig:disconnected123}
\end{figure}

%============== Incid ====================================================
\subsection{Incidence Graph}\label{sec:incid}
The incidence graph is a bipartite graph that we present in a way that creates a one to one correspondence with the 
Boolean formula it does represent. For an example of an incidence graph visualization see \ref{fig:incidencestep6}

This bipartite graph is prepared with good default values, but is customizable in many parameters.
Those values are:

\begin{enumerate}
	\item \textit{colors}, an iterable of colors that is used to color different nodes
	\item \textit{inc\_file}, basis for the file created that gets appended with the step number
	\item \textit{view}, could automatically open the generated files with the default program
	\item \textit{fontsize}, the size of all text in this graph
	\item \textit{penwidth}, width of the lines around nodes
	\item \textit{basefill}, filling of the background for nodes
	\item \textit{sndshape}, shape of the nodes with variables
	\item \textit{neg\_tail}, the shape of the edge-tail indicating a negated variable
	\item \textit{var\_name\_one/two}, prefix for nodes in the left (right) partition
	\item \textit{column\_distance}, the distance between both partitions
\end{enumerate}

We create the graph, add the necessary arguments and two sub-graphs. 
The first subgraph is called \textit{cluster\_clause} with it's label \textit{clauses}.
We add the clauses with their clause-ids starting at one sorted in ascending order from top to bottom.

The second sub-graph we call \textit{cluster\_ivar} labeled \textit{variables} gets all variables added to it, 
starting from variable-id one. 
This sub-graph does get the different provided \textit{colors} applied to its nodes and their adjacent edges.

The last step in this method is the highlighting of "active" parts in each time step beeing processed during it's dynamic programming. To accomplish this with as small overhead as possible, we apply and remove additional lines to the body of its graph source code. 
For highlighting there are two main cases:
\begin{itemize}
	\item There is no active clause in this step: we only reset highlighting
	\item Else: we also create new highlighting for clauses, variables and edges
\end{itemize}
In each case we create one image after the step to provide the inside generated.

%============== General Graph ====================================================
\subsection{General Graph}
The so called "general graph" can represent the underlying graph for different problems, as well as primal and dual graph for Boolean formulas.
Because of its larger area of application the general graph was not as easy to layout as the incidence graph.
We did prepare two different layouts that should cover most cases and are toggled by the parameter \textit{do\_sort\_nodes}.
For smaller and dense graphs of up to 20 vertices it might be helpful to sort the nodes on a circle, while for larger or sparse graphs an organic layout may be more appropriate.

To layout these two options we chose the engine 
\begin{itemize}
	\item \textit{do\_sort\_nodes} true: circo (see \cite{ST99})
	\item \textit{do\_sort\_nodes} false: sfdp (see \cite{Hu05}) with the spring constant 'K' set to 2.
\end{itemize}

Additional parameters used in both layouts are set to not overlap nodes and easily identify each node, as well as drawing the edges first. This should provide a minimally cluttered layout compared to the defaults, but could make edges ambiguous in some cases. Of course these layouts could use even more configuration than what was set for this version, a complete overview is provided in the \href{https://graphviz.org/doc/info/attrs.html}{graphviz-doc}. 

Only if the option to sort the nodes was chosen with \textit{do\_sort\_nodes} the method
\begin{enumerate}
	\item saves the current graph source 
	\item sets the layout engine to \textit{circo}
	\item adds edges between successive node-ids to form a closed circle
	\item runs the layout and reads back the output in plain dot-format
	\item reads the calculated positions for each node in the graph
	\item resets the source to step one, removing all temporary additions
	\item writes the calculated positions into each node
	\item sets the layout engine to an engine that uses those calculated positions later.
\end{enumerate}

We add the edges, and eventually the isolated nodes also, to the graph.
Then the highlighting for each time-step is done basically like in the incidence graph \ref{sec:incid}.
We allow one additional option that would depend on the concrete algorithm being visualized, and that is \textit{do\_adj\_nodes}.
In case the algorithm uses adjacent nodes they can be visualized with this flag using a third color.

% --- EXAMPLE
EXAMPLES

In each case we create one image after the time step to provide the inside generated.

%============== Joining SVG ====================================================
\subsection{Joining SVG}{Joining each time step into one image}
Once all user defined images for one timeline are created, it would be nice to have only one file for every step.
To support this functionality and some basic scaling and adjusting, there is a special key in the API for joining the svg-graphs. 
The functionality is placed in the file \textit{svgjoin.py} and will be called with the specifications given in the optional dictionary \textbf{svgjoin} within the JsonAPI.

We transform this information into the python \textit{dataclass} \textbf{SvgJoinData} \ref{lst:svgjoindata}.
% Show example with description of parameters 
The internally used method \textit{svgjoin.append\_svg} joins two images horizontally in each step.
With default settings it will align the top of both images and apply no scaling to either of them.
The possible parameters (in [unit])
\begin{itemize}
	\item centerpad: float = 0, [image coordinates], just "padding" in the JSON API
	\item v\_bottom: float = None, [size of the \textit{first} image]
	\item v\_top: float = None, [size of the \textit{first} image]
	\item scale2: float = 1, [size of the \textit{second} image]
\end{itemize}
allow flexible and easy to use vertical, horizontal and scaling transformations.
Note that the images are placed in a Cartesian coordinate system and its origin is the top left corner of its bounding box. All images fill a rectangle in this coordinate system with height and width respectively.

Since the order of the parameters \textit{v\_bottom} and \textit{v\_top} could be confused due to the coordinate system, we make sure to correctly set \textit{v\_top} to the smaller and \textit{v\_bottom} to the larger one if this is possible.

One special case is achieved by setting both these parameters to the same number. Then they are interpreted as the position of the vertical centerline for the second image in units of the first. So setting both parameters to $\dfrac{1}{2}$ would result in centering both images vertically.

Possibilities for joining images with these four parameters include:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/svgjoinpad200.png}
	\caption{Joining the blue (right side) image to the left gray image with only one parameter \textit{centerpad} set to 200. We see the default vertical position v\_top=0, and the implied coordinate system with an origin in the top left corner.}
	\label{fig:svgjoinpad200}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{images/svgjoinpad0.png}
	\caption{Example f0r joining with no \textit{centerpad}.}
	\label{fig:svgjoinpad0}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/svgjoinscale1.png}
	\caption{The second image gets scaled to the same size as the first image. This can be conveniently achieved by setting \textit{v\_top} to 0 and \textit{v\_bottom} to 1. Parameter \textit{centerpad} is 200 as hinted.}
	\label{fig:svgjoinscale1}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/svgjoinpad0centered.png}
	\caption{Aligning both images to be vertically centered. \\
		This can be achieved by setting $v\_bottom=v\_top=0.5$.}
	\label{fig:svgjoinpad0centered}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/svgjoinscaled.png}
	\caption{Setting \textit{scale2} to $1.3$ to scale the blue (right) image uniformly. Parameter \textit{centerpad} is 200 as hinted.}
	\label{fig:svgjoinscaled}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/svgjoinscaledbottom.png}
	\caption{As in figure \ref{fig:svgjoinscaled} we use \textit{scale2} to scale the blue rectangle. To align both images at the bottom edge, we use the value $v\_bottom=1$.}
	\label{fig:svgjoinscaledbottom}
\end{figure}

If we want to merge more than two images it is possible to specify the parameters in a list.
The list can be of different length for each parameter - if it is exhausted the last parameter in the list will be repeatedly used until all images are joined together.
% perspective 

% Checking with www.deepcode.ai

%==============================================================================
%============== GPUSAT ========================================================
%==============================================================================
\newpage
\section{Integration in GPUSAT}
To study and improve the handling of the C++ program was chronologically the first task I experimented with.
Getting the program up and running proved to be more difficult than we envisioned due to a probable bug in the driver when running OpenCL Drivers from CUDA on the Windows OS.

%=================Performance=======================
Impact on performance:
Utilizing small classes and \href{http://www.cplusplus.com/reference/sstream/stringstream/}{streams} we tried to keep the impact on performance during the solving process low. However running on the same thread especially for larger problem instances 

Some non-functional changes made to the source were 
\begin{itemize}
	\item[a)] some adjustments to satisfy the local compiler (shortening kernel string, replacing '\emph{and}' with '\&\&')
	\item[b)] some explicit casts
	\item[c)] fixed documentation of command line arguments
\end{itemize}

The functional changes were:
\begin{enumerate}
	\item allow tabs instead of spaces in input files
	\item output more information about the hardware used (device\_query)
	\item add verbose output globally toggled by a flag 
	\item decide on \url{https://en.wikipedia.org/wiki/DOT_\%28graph_description_language\%29} 
		as the intermediate format for storing graphs.
	\item start collecting information that might be needed for a visualization
		\emph{graphfile} for saving the decomposition graph
	\item add \emph{graphout }to solver flow to get automated insight into the structure of a run.
	
	\item add function \emph{solutiontable} to extract tables of variable assignments as a string
	\item add labels to each node (bags and solutions at this point)
	\item encapsulating the previous functions into gpusat::Graphoutput class and instantiate it in main.
	\item using the class functionality in the Solver
	\item changing enum to the \href{https://coders-corner.net/2017/08/13/scoped-vs-unscoped-enum/}{scoped enum class} for better encapsulation and strongly typed.
	\item with \href{https://github.com/daajoe/GPUSAT/commit/cfb310}{inlining gpusatutils} the current functionality of creating raw dot was completed.
	
	\item Experimented with Neo4j, but found the visualization in particular not that presentable. The functionality to create \href{https://neo4j.com/developer/cypher-resources/}{cypher-queries} for the SAT formula with primal, incidence and dual graph is still present in the class.
	\item The functionality to create the cypher-query for the graph of the tree-decomposition was added.
	\item Rename \textit{visualisierung} into \textit{visualization}
	\item Using \href{https://github.com/open-source-parsers/jsoncpp}{JsonCPP} for processing and formatting json objects in C++
	\item Setting format to {BasedOnStyle: LLVM, UseTab: Never, IndentWidth: 4, TabWidth: 4, ColumnLimit: 0}
	\item Creating a \emph{Grid} class for efficiently storing unsigned integer values in a two-dimensional structure
	based on ideas from \href{https://stackoverflow.com/questions/936687}{this thread}
	\item create \href{https://github.com/VaeterchenFrost/GPUSAT/blob/master/VisualCodeUsage.md}{guide} for remote development with \emph{Visual Code}
	\item Converted intermediate string operations to string-streams instead of files
	\item Updated README.md
	\item Added Doxygen for docbook, html, latex	
\end{enumerate}
Programm \url{https://github.com/VaeterchenFrost/GPUSAT} \\
Differences: \url{https://github.com/daajoe/GPUSAT/compare/master...VaeterchenFrost:master}  Commits 142 Files changed 94 
Nagoya talk:
Graphs for performance are Ordered by used time per algorithm - gpusat quite good

Working with cmake remotly. ssh @(sg1.)dbai.tuwien.ac.at
CPU branch wasn't working.
Only AMD/Nvidia graphics  with respective flags.

Manual configuration with the include options from \href{https://cmake.org/}{cmake} in \href{https://github.com/VaeterchenFrost/GPUSAT/blob/master/CMakeLists.txt}{CMakeLists.txt}
or with help from \url{https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools}
to set up for the (potentially remote) environment.

\begin{itemize}
	\item 
	\item Options:
\end{itemize}


\begin{longtable}{ll}
	\caption{Usage: ./gpusat [OPTIONS]
		\label{tab:optionsgpusat}}\\
	\hline
	\vspace{0.5ex}
	\endfirsthead
-s, -{}-seed INT&  number used to initialize the pseudorandom number generator\\
	-f, -{}-formula TEXT &  path to the file containing the sat formula\\
	-d, -{}-decomposition TEXT  &   path to the file containing the tree decomposition\\
	-{}-CPU                   &    run the solver on a cpu\\
	-{}-NVIDIA                &    run the solver on an NVIDIA device\\
	-{}-AMD                   &    run the solver on an AMD device\\
	-{}-weighted              &   use weighted model count\\
	-{}-noExp                 &    don't use extended exponents\\
	-v, -{}-verbose            &    print additional program information\\
	-p, -{}-nopreprocess       &    skips the preprocessing step for debugging and visualization-purposes\\
	-w, -{}-combineWidth INT=20&    maximum width to combine bags of the decomposition\\
	-g, -{}-graph TEXT         &    filename for saving the decomposition graph\\
	-{}-visufile TEXT         &    filename for saving the visualization file\\

\end{longtable}      
        
An example call with \textit{./gpusat -f ../examples/test\_da4\_1.cnf -v -p -d ../examples/td4p1.txt  -g ../examples/graphfileda41.txt -{}-visufile ../examples/visufileda41.json} enabled verbose output, disabled pre-processing to prevent the creation of bags with too many variables at once to be visualized, and creates full visualization output. 
The console output produced by this example call is listed in \ref{lst:outputGpusat}.

%============== Graphoutput ====================================================
\subsubsection{Class Graphoutput}\label{chagraphoutput}
First steps to automatically visualize the tree decomposition of the solving process with its solutions.
Outputs a graph specified in gml\cite{Himsolt2010GMLAP} (Graph Modeling Language).
For our example for \#SAT~\ref{lst:g41digraphdot} with the bags and respective solutions as nodes connected to the bag they solve.

Two additional functions generate a \href{https://neo4j.com/docs/cypher-refcard/current/}{Neo4j Cypher} query with:
\begin{itemize}
	\item one graph representing the SAT formula and  queries to construct incidence, dual and primal representations.
	output as satFile = "cypherSatFormula.txt"
	\item one graph representing the tree decomposition of the primal graph with it's bags containing variables.
	output as tdFile = "cypherTreedec.txt"
\end{itemize}

%============== SolverVisualization ====================================================
\subsubsection{Class SolverVisualization}

To include the extraction of all necessary visualization information into the solver I created a separate fork.
To simplify the creation of valid json I selected the actively developed c++ library JsonCpp \url{https://github.com/open-source-parsers/jsoncpp} version 1.9.2 from the open-source-parsers repository.

%==============================================================================
%============== DPDB ==========================================================
%==============================================================================
\newpage
\section{Integration in dpdb}
The integration of the API with dpdb was easier to implement after the solving process instead of
hooking into the solving, 
provided that all necessary information got persisted in the database.
The integration is included in the TDVisu project as a separate python file.
A complete workflow can be accomplished using the arguments
\begin{itemize}
	\item -{}-store-formula as a problem specific option for Sat and SharpSat
	\item -{}-gr-file GR\_FILE for problems like VertexCover with graph input 
\end{itemize}
when calling dpdb.py\\
The integration for SharpSat was the first implemented in the file \textit{construct\_dpdb\_visu.py} with
the main parameters

\begin{itemize}
	\item
	\textbf{problemnumber}
	 the problem-id to select in the database
	 
	\item
	\textbf{-{}-twfile }TWFILE
	tw-file containing the edges of the graph 
	
	\item
	\textbf{-{}-outfile }OUTFILE
	 file to write the output to, default 'dbjson\%d.json'
	 
	\item
	\textbf{-{}-loglevel }LOGLEVEL
	 set the minimal loglevel for the root logger
	 
	\item
	\textbf{-{}-pretty}
	 pretty-print the JSON
	 
	\item
	\textbf{-{}-inter-nodes}
	Calculate and animate the shortest path between successive bags in the order of evaluation. To accomplish this task, an efficient implementation of the bidirectional Dijkstra's algorithm \cite{shortestPathAlgo} based on the implementation by NetworkX \cite{SciPyProceedings_11} in \href{https://networkx.github.io/documentation/networkx-2.1/reference/algorithms/generated/networkx.algorithms.shortest_paths.weighted.bidirectional_dijkstra.html#networkx.algorithms.shortest_paths.weighted.bidirectional_dijkstra}{bidirectional\_dijkstra}.
	in our case the weight function is always one, as the edges have no weight associated with them.
\end{itemize}
After the arguments are parsed by \href{https://docs.python.org/3/library/argparse.html}{pythons argparse} it is possible to adjust logging output by either providing a configuration file (\href{https://github.com/VaeterchenFrost/tdvisu/blob/master/tdvisu/logging.yml}{template} provided) or giving a minimal logging level per program argument.

!!! Database Config!!!

Next the \textit{create\_json}~\ref{lst:create-json} function connects to the database driver with 
the number of the stored problem. 
The "problem type" is available as a string in table \emph{public.problem}, and the appropriate class to prepare the json will be instantiated. At this time the solver handles the problems of \textit{satisfiability} (Sat), \textit{count solutions to a Boolean formula} (SharpSat) as well as \textit{minimum vertex cover} (VertexCover).


Beispiel

%==============================================================================
%============== APPLICATION ===================================================
%==============================================================================
\newpage
\section{Application and Images }

% Appl. Sat
\subsection{SAT Example}
In this section we will visualize the process of checking the formula \ref{ex:example41} for solvability. We have six time steps included in this visualization. First we will look at the bags in the tree-decomposition. As some simple debugging information we added the time to solve each bag individually into the labels.

\begin{figure}[H]
	\centering
	\includegraphics[height=0.6\textheight]{images/DA4SAT/results/TDStep1.pdf}
	\caption{Tree decomposition for solving example \ref{ex:example41} . \\
		With yellow highlighting for the first leaf (bag 5) to solve.}
\end{figure}
\begin{table}\sffamily
\begin{tabular}{l*3{c}}
	\toprule
	2 & \includegraphics[height=0.46\textheight]{images/DA4SAT/results/TDStep2.pdf} &
	3 & \includegraphics[height=0.46\textheight]{images/DA4SAT/results/TDStep3.pdf} \\ 
	\midrule
	4 & \includegraphics[height=0.46\textheight]{images/DA4SAT/results/TDStep4.pdf} &
	5 & \includegraphics[height=0.46\textheight]{images/DA4SAT/results/TDStep5.pdf}\\
	\bottomrule 
\end{tabular}
\caption{Tree decomposition for solving example \ref{ex:example41} . Images for steps two to five as labeled from top left to bottom right.}
\end{table} 

\begin{figure}[H]
	\centering
	\includegraphics[height=0.6\textheight]{images/DA4SAT/results/TDStep6.pdf}
	\caption{Tree decomposition for solving example \ref{ex:example41} . \\
		Final result with yellow highlighting for the last bag (1) solved.}
\end{figure}

\begin{figure}[H]
	\setkeys{Gin}{width=\linewidth,height=0.45\textheight,keepaspectratio}
	\begin{tabularx}{\textwidth}{ l X X }
		step 1: &\includegraphics[valign=c]{images/DA4SAT/results/IncidenceGraphStep1.pdf} & \includegraphics[valign=c]{images/DA4SAT/results/PrimalGraphStep1.pdf} \\ 
		step 2: &\includegraphics[valign=c]{images/DA4SAT/results/IncidenceGraphStep2.pdf} & \includegraphics[valign=c]{images/DA4SAT/results/PrimalGraphStep2.pdf} \\ 
		&Visualization of the incidence graph including information for the sat formula & 
		\centering Visualization of the primal graph \\
	\end{tabularx}
	\caption{Incidence graph and primal graph of example \ref{ex:example41} .}
\end{figure}

% Appl. SharpSat
\subsection{\#SAT Example}
Like the previous example section we are interested in solutions to example \ref{ex:example41}. This time we want to solve \#SAT and count the number of solutions, that is the number of satisfying assignments. While the tree decomposition and SAT formula stay the same, we can add one column to our solution-tables compared to pure SAT solving and label this column \textit{mc} for "\textit{model-count}". We also included a footer with the API to display the sum of all models considered up to this bag.
\begin{figure}[H]
	\centering
	\includegraphics[height=0.6\textheight]{images/DA4/TDStep2.pdf}
	\caption{Tree decomposition for solving example \ref{ex:example41} with yellow highlighting of the solution for the first leaf.}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[height=0.9\textheight]{images/DA4/TDStep6.pdf}
	\caption{Tree decomposition for solving example \ref{ex:example41}. The highlighted bag 1 points to the solution of the problem, containing 22 solutions and satisfying variable assignments for $v_{1},v_{2},v_{5}$ contained in \textit{sol bag 1}.}
\end{figure}
% Appl. VC
\subsection{Vertex Cover Example}

% Appl. svgjoin with different options
\subsection{SVG Join Example}

%==============================================================================
%============== Conclusion ====================================================
%==============================================================================
\newpage
\section{Conclusion}
%What is achieved?
% Open source Assistant for visualizing dynamic programming on tree decompositions
% Small dataformat, highly adaptable svg format
% Two example integrations in actively developed MSO solvers
% Bags do provide the option to add arbitrary many/long labels for different debugging information
\subsection{Summary}
We created and could for the most part automate visualization of dynamic programming on tree decompositions.
With SVG we by default do support a human readable, highly adaptable data format.\\

We defined and developed a data-exchange form to give the visualization the information it will need and provide sensible default values for (almost) all parameters.\\

The visualization got implemented and tested in two actively developed solvers for the problem types \textbf{SAT}, \textbf{\#SAT} and \textbf{minimal vertex cover}.\\

During development we already found some improvements in the solvers and easily identified possible bugs.
All nodes are prepared to display arbitrary user defined strings that could include various debugging-information about the run.

\subsection{Future Work}
% Graphs could provide more options to the user
% Generate multiple bipartite and general graphs
% Operate on hypergraphs
% Bring all timesteps into one file, e.g Animations
In the future our graphs could provide even more parameters to the user. \\

Different colors visualizing attributes of each node are a consideration.\\

The next step would be to expand the API to multiple bipartite or simple graphs, which right now is limited to one each with the option to create primal- and dual-graphs too.\\

One addition could be the inclusion of hypergraphs (graphs where one edge does connect multiple nodes) which could be of interest to solvers of the future.\\

Right now even with the \textit{svg-join} tool we need multiple files to represent all time steps. SVG however would be able to only create one file where the time steps will be animated. Animations might get toggled by the user or change over a specified time span.
%==============================================================================
%============== APPENDIX ======================================================
%==============================================================================
\newpage
\appendix
\section{Images}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{images/logictheory.png}
	\caption{From propositional logic to monadic second order logic and Courcelle's Theorem}
	\label{fig:logictheory}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[height=\textheight]{images/g41digraphdot.png}
	\caption{Created scalable-vector-graphic directly from \ref{lst:g41digraphdot}}
	\label{fig:g41Digraph}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\linewidth]{images/IncidenceStep6.png}
	\caption{Example for an incidence graph from example 4.1}
	\label{fig:incidencestep6}
\end{figure}
\newpage
\section{Code Snippets}


\lstinputlisting[caption={The JSON format used to describe MSOL visualization on tree decompositions}, label={lst:jsonapi}]{includes/JsonAPI.txt}

\begin{lstlisting}[language={Python}, caption={Construct\_dpdb\_visu.py}, label={lst:create-json}]
def create_json(problem: int, tw_file=None, intermed_nodes=False):
	"""Create the JSON for the specified problem instance."""
	with connect() as connection:
		# get type of problem
		with connection.cursor() as cur:
			query = """SELECT name,type,num_bags 
			FROM public.problem WHERE id=%s"""
			cur.execute(query, (problem,))
			(name, ptype, num_bags) = cur.fetchone()
		
		constructor: IDpdbVisuConstruct  
		if ptype == 'SharpSat':
			constructor = DpdbSharpSatVisu(
						 connection, problem, intermed_nodes)
		elif ptype == 'VertexCover':
			constructor = DpdbMinVcVisu(
						 connection, problem, intermed_nodes, tw_file)
		return constructor.construct()
	return {} 
\end{lstlisting}

\begin{lstlisting}[language={Python}, caption={forward\_iterate\_tdg}, label={lst:forward-iterate}]
def forward_iterate_tdg(self, joinpre, solpre, soljoinpre) -> None:
"""Create the final positions of all nodes with solutions."""
	tdg = self.tree_dec_digraph                 # shorten name
	
	for i, node in enumerate(self.timeline):    # Create the positions
		if len(node) > 1:
			# solution to be displayed
			id_inv_bags = node[0]
			if isinstance(id_inv_bags, int):
				last_sol = solpre % id_inv_bags
				tdg.node(last_sol, solution_node(
				*(node[1])), shape='record')	
				tdg.edge(self.bagpre % id_inv_bags, last_sol)
			
			else:    # joined node with 2 bags
				suc = self.timeline[i + 1][0]   # get the joined bags
				
				LOGGER.debug('joining %s to %s ', node[0], suc)
				
				id_inv_bags = tuple(id_inv_bags)
				last_sol = soljoinpre % id_inv_bags
				tdg.node(last_sol, solution_node(
				*(node[1])), shape='record')
				
				tdg.edge(joinpre % id_inv_bags, last_sol)
				# edges
				for child in id_inv_bags:  # basically "remove" current
					tdg.edge(
							self.bagpre % child
							if isinstance(child, int) else joinpre % child,
							self.bagpre % suc
							if isinstance(suc, int) else joinpre % suc,
							style='invis',
							constraint='false')
					tdg.edge(self.bagpre % child if isinstance(child, int)
					         else joinpre % child,
					         joinpre % id_inv_bags)
				tdg.edge(joinpre % id_inv_bags, self.bagpre % suc
					if isinstance(suc, int) else joinpre % suc)
\end{lstlisting}

\begin{lstlisting}[language={Python}, caption={backwards\_iterate\_tdg}, label={lst:backward-iterate}]
def backwards_iterate_tdg(self, joinpre, solpre, soljoinpre,
                          view=False) -> None:
	"""Cut the single steps back and update emphasis acordingly."""
	tdg = self.tree_dec_digraph     # shorten name
	last_sol = ""
	
	for i, node in enumerate(reversed(self.timeline)):
		id_inv_bags = node[0]
		LOGGER.debug("%s: Reverse traversing on %s", i, id_inv_bags)
		
		if i > 0:
			# Delete previous emphasis
			prevhead = self.timeline[len(self.timeline) - i][0]
			bag = (
				self.bagpre %
				prevhead if isinstance(
				prevhead,
				int) else joinpre %
				tuple(prevhead))
			base_style(tdg, bag)
			if last_sol:
				style_hide_node(tdg, last_sol)
				style_hide_edge(tdg, bag, last_sol)
				last_sol = ""
		
		if len(node) > 1:
			# solution to be displayed
			if isinstance(id_inv_bags, int):
				last_sol = solpre % id_inv_bags
				emphasise_node(tdg, last_sol)
				tdg.edge(self.bagpre % id_inv_bags, last_sol)
			else:  # joined node with 2 bags
				id_inv_bags = tuple(id_inv_bags)
				last_sol = soljoinpre % id_inv_bags
				emphasise_node(tdg, last_sol)
			
		emphasise_node(tdg,
			self.bagpre %
			id_inv_bags if isinstance(id_inv_bags, int) else 
			joinpre % id_inv_bags)
		_filename = self.outfolder + self.data.td_file + '%d'
		tdg.render(
			view=view, format='svg', filename=_filename %
			(len(self.timeline) - i))

\end{lstlisting}

\begin{lstlisting}[language={Python}, caption={SvgJoinData}, label={lst:svgjoindata}]
@dataclass
class SvgJoinData:
	"""Class for holding different parameters to join the results."""
	base_names: Union[str, Iterable[str]]
	folder: Optional[str] = None
	outname: str = 'combined'
	suffix: str = '%d.svg'
	preserve_aspectratio: str = 'xMinYMin'
	num_images: int = 1
	padding: Union[int, Iterable[int]] = 0
	scale2: Union[float, Iterable[float]] = 1.0
	v_top: Union[None, float, str, 
	             Iterable[Union[None, float, str]]] = 'top'
	v_bottom: Union[None, float, str, 
	                Iterable[Union[None, float, str]]] = None
\end{lstlisting}
\section{Input Examples}

\lstset{numbers=none}
\begin{lstlisting}[caption={Edge encoding of example graph with 16 vertices}, label={lst:minvc16}]
p tw 16 36
1 2
2 1
2 3
3 2
3 4
4 3
3 5
5 3
4 5
5 4
4 6
6 4
6 7
7 6
7 8
8 7
8 9
9 8
9 10
10 9
9 11
11 9
11 12
12 11
12 13
13 12
12 14
14 12
11 14
14 11
14 7
7 14
6 15
15 6
15 16
16 15
\end{lstlisting}
\begin{lstlisting}[caption={CNF clauses from example 4.1 on page 27 \cite{DiplomarbeitZisser}}, label={lst:clausesDA41}]
p cnf 8 10
1 4 6 0
1 -5 0
-1 7 0
2 3 0
2 5 0
2 -6 0
3 -8 0
4 -8 0
-4 6 0
-4 7 0
\end{lstlisting}
\begin{lstlisting}[caption={CNF clauses from random example with 12 units},label={lst:example18-24}]
p cnf 18 24
-1 0
-2 0
-3 0
-4 0
-5 0
-6 0
-7 0
-8 0
-9 0
-10 0
-11 0
-12 0
-13 -14 -15 0
-13 -14 16 0
-13 -15 -16 -18 0
-13 -15 -17 0
13 14 16 -17 18 0
13 15 -16 -18 0
-14 -15 16 17 0
-14 15 -17 18 0
-14 15 17 -18 0
-15 -16 -17 18 0
15 -16 -17 -18 0
15 16 17 -18 0
\end{lstlisting}
\lstinputlisting[caption={DOT source for visualization of example 4.1}, label={lst:g41digraphdot}]{includes/g41digraphdot}
\lstinputlisting[caption={stdout of program gpusat with call \textit{./gpusat -f ../examples/test\_da4\_1.cnf -v -p -d ../examples/td4p1.txt  -g ../examples/graphfileda41.txt -{}-visufile ../examples/visufileda41.json}}, label={lst:outputGpusat}]{includes/outputGpusat.txt}

%==============================================================================
%============== BIBLIOGRAPHY ==================================================
%==============================================================================
\newpage
\printbibliography
%\bibliography{bibtex}{}
%\bibliographystyle{ieeetr}
\end{document}
